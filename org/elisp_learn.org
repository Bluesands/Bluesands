* Emacs Lisp 简明教程
  该教程是[[http://smacs.github.io/elisp/][叶文彬写的 Emacs Lisp 的教程]]，在这里记录学习笔记。
** 基础知识
*** 函数与变量
    elisp 定义一个函数形式如下：
    #+BEGIN_SRC elisp
    (defun function-name (arguments-list)
    "document string"
    body)
    #+END_SRC
    example:
    #+BEGIN_SRC elisp
    (defun hello-word (name)
    "Say hello to user whose name is Name."
    (message "Hello, %s" name))
    (hello-word "Bluesands")
    #+END_SRC

    #+RESULTS:
    : Hello, Bluesands

    可以使用 C-h f 输入函数名查看函数帮助。
    每个函数都有一个返回值，这个返回值一般是函数定义里的最后一个表达式的值。

    elisp 里的变量使用无需像 c 语言那样需要声明，你可以使用 setq 直接对一个变量赋值。
    #+BEGIN_SRC elisp
    (setq foo "I'm foo")
    (message foo)
    #+END_SRC

    #+RESULTS:
    : I’m foo

    可以使用 C-h v 输入变量名查看变量文档

    有一个特殊的表达式(special form) defvar，它可以声明一个变量，一般形式是：
    #+BEGIN_SRC elisp
    (defvar variable-name value
    "document string")
    #+END_SRC
    它与 setq 的区别是，如果变量在声明之前已经有一个值的话，用 defvar 声明的变量不会改变成声明的值。另一个区别是 defvar 可以为变量提供文档字符串。
    #+BEGIN_SRC elisp
    (defvar foo "Did I have a value?"
    "A demo variable")
    foo
    #+END_SRC

    #+RESULTS:
    : Did I have a value?
    
    由于 elisp 中函数是全局的，变量也很容易成为全局变量（因为全局变量和局部变量的赋值都是使用 setq 函数），名字不互为冲突是很关键的。所以除了为你的函数和变量选择一个合适的前缀之外，用 C-h f 和 C-h v 查看一下函数名和变量名有没有被使用过是很关键的。
*** 局部作用域的变量
   如果没有局部作用域的变量，都使用全局变量，函数会相当难写，elisp 使用 let 和 let*进行局部变量绑定。 
   #+BEGIN_SRC elisp
   (let (bindings)
   body)
   #+END_SRC
   bindings 可以是(var value)这样对 var 赋初始值，或则使用 var 声明一个初始值为 nil 的变量。
   #+BEGIN_SRC elisp
   (defun circls-area (radix)
   (let ((pi 3.1415929)
   area)
   (setq area (* pi radix radix))
   (message "直径%.2f 的圆面积是%.2f" radix area)))
   (circls-area 3)
   #+END_SRC

   #+RESULTS:
   : 直径 3.00 的圆面积是 28.27
   
   let*和 let 的形式完全相同，区别是 let*声明中可以是使用前面声明过的变量：
   #+begin_src emacs-lisp :tangle yes
   (defun circls-area (radix)
   (let* ((pi 3.1415926)
   (area (* pi radix radix)))
   (message "直径%.2f 的圆面积是%.2f" radix area)))
   (circls-area 3)
   #+end_src

   #+RESULTS:
   : 直径 3.00 的圆面积是 28.27
*** lambda 表达式
    可能你久闻 lambda 表达式的大名了，其实 lambda 表达式相当与其他语言的匿名函数：
    #+BEGIN_SRC emacs-lisp
    (lambda (arguments-list)
    "documentation string"
    body)
    #+END_SRC
    lambda 使用实例：
    #+BEGIN_SRC emacs-lisp
    (funcall (lambda (name)
    (message "Hello, %s!" name)) "Emacser")
    #+END_SRC

    #+RESULTS:
    : Hello, Emacser!
    或者将 lambda 表达式赋值给一个变量，然后 funcall 调用：
    #+BEGIN_SRC emacs-lisp
    (setq foo (lambda (name)
    (message "Hello, %s!" name)))
    (funcall foo "Emacser")
    #+END_SRC

    #+RESULTS:
    : Hello, Emacser!
    lambda 表达式最常用的作用是作为参数传递给其他函数，比如 mapc。

*** 控制结构
    顺序执行
    一般来说程序都是按表达式顺序依次执行的，这在 defun 特殊环境中是自动执行的。但是一般情况下都不是这样的，比如你无法用 eval-last-sexp 同时执行两个表达式，在 if 表达式中的条件为真执行的部分也只能运行一个表达式。这时就需要用 progn 这个特殊的表达式，它的使用形式如下：
    #+BEGIN_SRC emacs-lisp
    (progn A B C ...)
    #+END_SRC
    它的作用就是让表达式 A,B,C 顺序执行。比如：
    #+BEGIN_SRC emacs-lisp
    (progn
    (setq foo 3)
    (message "Square of %d is %d" foo (* foo foo)))
    #+END_SRC

    #+RESULTS:
    : Square of 3 is 9
    
    条件判断
    elisp 有连个最基本的条件判断表达式 if 和 cond。使用形式分别如下：
    #+BEGIN_SRC emacs-lisp
    (if condition
    then
    else)
    (cond (case1 do-when-case1)
    (case2 do-when-case2)
    ...
    (t do-when-none-meet))
    #+END_SRC
    使用实例如下：
    #+BEGIN_SRC emacs-lisp
          (defun my-max (a b)
            (if (> a b)
                a b))
          (my-max 3 4)

      (defun fib (n)
        (cond ((= n 0) 0)
              ((= n 1) 1)
              (t (+ (fib (- n 1))
                    (fib (- n 2))))))
      (fib 10)
    #+END_SRC

    #+RESULTS:
    : 55
    还有两个宏 when 和 unless，从它们的名字就知道它们是什么用的。使用这两个宏的好处是使代码可读性提高，when 能省去 if 里的 progn 结构，unless 省去条件为真子句需要的 nil 表达式。
    
    循环
    使用循环 while 表达式：
    #+BEGIN_SRC emacs-lisp
      (while condition
        body)
    #+END_SRC
    实例：
    #+BEGIN_SRC emacs-lisp
      (defun factorial (n)
        (let ((res 1))
          (while (> n 1)
            (setq res (* res n)
                  n (- n 1)))
          res))
      (factorial 10)
    #+END_SRC

    #+RESULTS:
    : 3628800

逻辑运算
条件的逻辑运算和其他语言都是很类似的，使用 and、or、not。and 和 or 同样具有短路性质。很多人喜欢在表达式短时，用 and 代替 when，or 代替 unless。当然这时一般不关心它们的返回值，而是在于表达式其它子句的副作用。比如 or 经常用于设置函数的缺省值，而 and 常用与参数检查：
#+BEGIN_SRC emacs-lisp :export results output append
  (defun hello-world (&optional name)
    (or name (setq name "Emacser"))
    (message "Hello, %s" name))

  (hello-world)
  (hello-world "Ye")
#+END_SRC

#+RESULTS:
: Hello, Ye

** 基本数据类型
*** 数字
    emacs 的数字分为整数和浮点数（没有 c 的双精度数 double），其中 integer 可以使用 most-positive-fixnum 和 most-negative-fixnum 两个变量得到范围；float 可以使用 most-positive-float 和 most-negative-float 得到范围。
    #+BEGIN_SRC emacs-lisp :results output
      (princ (format "This machine integer max is %d and min is %d.\n" most-positive-fixnum most-negative-fixnum))
      (princ (format "This machine float max is %s and min is %s." most-positive-float most-negative-float))
    #+END_SRC

    #+RESULTS:
    : This machine integer max is 2305843009213693951 and min is -2305843009213693952.
    : This machine float max is nil and min is nil.
    
    测试函数
    整数类型测试函数是 integerp，浮点数类型测试函数是 floatp。数字类型测试用 numberp。你可以分别运行这几个例子来试验一下：
    #+BEGIN_SRC emacs-lisp :results output :exports results
      (princ (integerp 1.))
      (print (integerp 1.0))
      (princ (floatp 1.))
      (print (floatp -0.0e+NaN))
      (princ (numberp 1))
    #+END_SRC

    #+RESULTS:
    : t
    : nil
    : nil
    : t
    : t
    还提供一些特殊测试，比如测试零的 zerop，还有非负整数测试的 wholenump。
    elisp 测试函数一般都是用 p 结尾，p 是 predicate 的第一个字母，如果函数名是一个单词，通常只是在这个单词后加一个 p，如果是多个单词，一般是加-p。
*** 字符和字符串
    大小写转换使用的是 downcase 和 upcase 两个函数。这两个函数的参数既可以字符串，也可以是字符。capitalize 可以使字符串中单词的地一个字符大写，其他字符消协。upcase-initials 只使第一个单词的第一个字符大写，其他字符小写。这两个函数的参数如果是一个字符，那么只让这个字符大写。
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (downcase "The cat is the hat"))
      (print (downcase ?X))
      (prin1 (upcase "The cat in the hat"))
      (print (upcase ?X))
      (prin1 (capitalize "The CAT in tHe hat"))
      (print (upcase-initials "The CAT in the hAt"))
    #+END_SRC

    #+RESULTS:
    : "the cat is the hat"
    : 120
    : "THE CAT IN THE HAT"
    : 88
    : "The Cat In The Hat"
    : "The CAT In The HAt"
    
    格式化字符串
    format 类似与 c 语言里的 printf 可以实现对象的字符串化。数字的格式化和 printf 的参数差不多，值得一提的是"%s"这个格式化形式，它可以把对象的输出形式转化成字符串，这在调试时很有用。
    查找和替换
    字符串查找的核心函数是 string-match。这个函数可以从指定的位置对字符串进行正则表达式匹配，如果匹配成功，则返回匹配的起点：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (string-match "34" "01234567890123456789"))
      (print (string-match "34" "01234567890123456789" 10))
    #+END_SRC

    #+RESULTS:
    : 3
    : 13
    注意 string-match 的采纳书是一个 regexp。emacs 好像没有内建的查找子串的函数。如果你想把 string-match 作为一个查找子串的函数，可以先用 regexp-quote 函数处理一下子串。
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (string-match "2*" "232*=696"))
      (print (string-match (regexp-quote "2*") "232*=696"))
    #+END_SRC

    #+RESULTS:
    : 0
    : 2
    
    string-match 在查找的同时，还会记录下每个要捕捉的字符串的位置。这个位置可以在匹配后用 match-data、match-beginning 和 match-end 等函数来获得。
    #+BEGIN_SRC emacs-lisp
      (progn
        (string-match "3\\(4\\)" "01234567890123456789")
        (match-data))
    #+END_SRC

    #+RESULTS:
    | 3 | 5 | 4 | 5 |

    #+BEGIN_SRC emacs-lisp :results output
      (let ((start 0))
        (while (string-match "34" "01234567890123456789" start)
          (princ (format "find at %d\n" (match-beginning 0)))
          (setq start (match-end 0))))
    #+END_SRC

    #+RESULTS:
    : find at 3
    : find at 13
    替换函数是 replace-match，可以用于字符串的替换，也可以用于缓冲区的文本替换，对于字符串的替换，replace-match 只是按给定的序号把字符串的那一部分用提供的字符串替换。
    #+BEGIN_SRC emacs-lisp :results output
      (let ((str "01234567890123456789"))
        (string-match "34" str)
        (prin1 (replace-match "x" nil nil str 0))
        (print str))
    #+END_SRC

    #+RESULTS:k
    : "012x567890123456789"
    : "01234567890123456789"

*** cons cell 和列表
    从概念上讲 cons cell 其实非常简单，就是两个有顺序的元素，第一个叫 CAR，第二个叫 CDR。CAR 和 CDR 名字来自与 Lisp。它最初在 IMB704 机器上的实现。在这种机器有一种取址模式，使人可以访问一个存储地址中的“地址（address）”部分和“减量（decrement）”部分。CAR 指令用与取出地址部分，表示（Contents of Address part of Register），CDR 指令用于取出地址的减量部分（Contents of the Decrement part of Register）。cons cell 也就是 construction of cell。car 函数用于取得 cons cell 的 CAR 部分，cdr 取出 cons cell 的 CDR 部分。cons cell 如此简单，但是它能衍生出许多高级的数据结构，比如链表，树，关联表等等。
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 '(1 . 2))
      (print '(?a . 1))
      (prin1 '(1 . "a"))
      (print '(1 . nil))
      (prin1 '(nil . nil))
    #+END_SRC

    #+RESULTS:
    : (1 . 2)
    : (97 . 1)
    : (1 . "a")
    : (1)
    : (nil)
    
    注意到前面的表达式中都有一个'号，这是什么意思？其实理解了 eval-last-sexp 的作用就明白了。eval-last-sexp 其实包含了两个步骤，一是读入前一个 S-表达式，二是对读入的 S-表达式求值。这样如果读入一个 cons cell 的话，求值时会把这个 cons cell 的第一个元素作为一个函数来调用。而事实上，前面的这些例子的地一个元素都不是一个函数，这样就会产生一个错误 invalid-function。之所以前面没有遇到这个问题，那是因为前面数字和字符串是一类特殊的 S-表达式，它们求值后和求值前是不变，称为自求值表达式（self-evaluating-form）。'号其实是一个特殊的函数 quote，它的作用就是将它的参数返回而不是作求值。'(1 . 2)等价与(quote (1 . 2)).
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 '(+ 2 3))
      (print (quote (1 . 2)))
      (prin1 (+ 2 3))
      (print (read "(1 . 2)"))
    #+END_SRC

    #+RESULTS:
    : (+ 2 3)
    : (1 . 2)
    : 5
    : (1 . 2)
    列表包括了 cons cell。但是列表中有一个特殊的元素-空表 nil。
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 nil)
      (print '())
    #+END_SRC

    #+RESULTS:
    : nil
    : nil
    空表不是一个 cons cell，因为它没有 CAR 和 CDR 两个部分，事实上空表里没有任何内容。但是为了编程的方便，可以认为 nil 的 CAR 和 CDR 都是 nil：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (car nil))
      (print (cdr nil))
    #+END_SRC

    #+RESULTS:
    : nil
    : nil
    按列表最后一个 cons cell 的 CDR 部分的类型分，可以把列表分为三类。如果是 nil，则称为“真列表”(true-list)。如果即不是 nil 也不是一个 cons cell，则这个列表称为“点列表”(dotted list)。还有一种可能，它指向列表中的一个 cons cell，则称为环形列表(circual list)。
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 '(1 2 3))
      (print '(1 2 . 3))
      (prin1 '(1 . #1=(2 3 . #1#)))
    #+END_SRC

    #+RESULTS:
    : (1 2 3)
    : (1 2 . 3)
    : (1 2 3 . #1)
    从这个例子可以看出前两种列表的读入语法和输出形式都是相同的，而环形列表的读入语法是很古怪的，输出形式不能作为环形列表的读入形式。
    如果把真列表最后一个 cons cell 的 nil 省略不写，也就是(1 . nil)简写成(1)，把(obj1 . (obj2 . list)简写成(obj1 obj2 . list)，那么列表最后可以写成一个用括号括起来的元素列表：
    #+BEGIN_SRC emacs-lisp
      (prin1 '(1 . (2 . (3 . nil))))
    #+END_SRC

    #+RESULTS:
    | 1 | 2 | 3 |

    测试函数
    测试一个对象是否是 cons cell 用 consp，是否是列表用 listp
    #+BEGIN_SRC emacs-lisp :results output 
      (prin1 (consp '(1 . 2)))
      (print (consp '(1 . (2 . nil))))
      (prin1 (consp nil))
      (print (listp '(1 . 2)))
      (prin1 (listp '(1 . (2 . nil))))
      (print (listp nil))
    #+END_SRC

    #+RESULTS:
    : t
    : t
    : nil
    : t
    : t
    : t
    没有内建的方法测试一个列表是不是一个真列表。通常如果一个函数需要一个真列表作为参数，都是在运行时发生错误，而不是进行参数检查，因为检查一个列表是真列表的代价比较高。
    测试一个对象是否是 nil 用 null 函数。只有当对象是空表时，null 才返回空值。
    构造函数
    生成一个 cons cell 可以用 cons 函数。比如：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (cons 1 2))
      (print (cons 1 '()))
    #+END_SRC

    #+RESULTS:
    : (1 . 2)
    : (1)
    也是在列表前面增加元素的方法。比如：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (setq foo '(a b)))
      (print (cons 'x foo))
    #+END_SRC

    #+RESULTS:
    : (a b)
    : (x a b)
    值得注意的是前面这个例子的 foo 值并没有改变。事实上有一个宏 push 可以加入元素的同时改变列表的值：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (push 'x foo))
      (print foo)
    #+END_SRC

    #+RESULTS:
    : (x a b)
    : (x a b)
    生成一个列表的函数是 list。比如：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (list 1 2 3))
    #+END_SRC

    #+RESULTS:
    : (1 2 3)
    quote（也就是'符号）和 cons 以及 list 的区别：quote 是把参数直接返回不进行求值，而 list 和 cons 是对参数求职后再生成一个列表或者 cons cell。例如：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 '((+ 1 2) 3))
      (print (list (+ 1 2) 3))
    #+END_SRC

    #+RESULTS:
    : ((+ 1 2) 3)
    : (3 3)
    前一个列表的 CAR 部分是（+ 1 2）这个列表，而后一个是先对（+ 1 2）求值得到 3 后在生成的列表。
    
    前面提到在列表前端增加元素的方法是 cons，在列表后端增加元素的函数是用 append。比如：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (append '(a b) '(c)))
    #+END_SRC

    #+RESULTS:
    : (a b c)
    append 的功能可以认为它把第一个参数最后一个列表的 nil 换成第二个参数，比如前面这个例子，第一个参数写成 cons cell 表示方法是(a . (b . nil))，把这个 nil 替换成(c)
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (append '(a b) '(c) '(d)))
    #+END_SRC

    #+RESULTS:
    : (a b c d)
    一般说来 append 的参数都要是列表，但是最后一个参数可以不是一个列表，这也不违背前面说的，因为 cons 的 CDR 部分本来就可以是任何对象：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (append '(a b) 'c))
    #+END_SRC

    #+RESULTS:
    : (a b . c)
    这样得到的结果就不再是真列表，如果再使用 append 就会报错。
    如果写过 c 的链表类型，可能就知道如果链表只保留一个指针，那么链表只能在一端增加元素。elisp 的列表类型也是类似的，用
cons 在列表前增加元素比用 append 要快的多。
		append 的参数不限于列表，还可以是字符串或者向量。前面字符串里已经提到可以把一个字符串转换成字符列表，同样可能把响亮转换成一个列表：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (append [a b] "cd" nil))
      (print (append [a b] "cd"))
    #+END_SRC

    #+RESULTS:
    : (a b 99 100)
    : (a b . "cd")
    注意前面最后一个参数 nil 是必要的，不然将得到点列表。
    
    把列表当数组用
    要得到列表或者 cons cell 里元素，唯一的方法是用 car 和 cdr 函数。很容易明白，car 就是去得 cons cell 的 CAR 部分，cdr 函数就是取得 CDR 部分，通过这两个函数，我们就能访问 cons cell 和列表中的任何元素。
    #+BEGIN_SRC emacs-lisp :results output
      (defun get-list-element (num tlist)
        (if (> num (length tlist))
            (message "The num %d out range of list %s" num tlist)
          (if (= num 1)
              (car tlist)
            (let ((num (- num 1))
                  (tlist (cdr tlist)))
              (get-list-element num tlist)
              )
            )
          )
        )

      (setq test (list 9 20 3 49))
      (prin1 (get-list-element 1 test))
      (print (get-list-element 2 test))
      (prin1 (get-list-element 3 test))
      (print (get-list-element 4 test))
      (prin1 (get-list-element 5 test))
      (print (get-list-element 6 test))
    #+END_SRC

    #+RESULTS:
    : 9
    : 20
    : 3
    : 49
    : "The num 5 out range of list (9 20 3 49)"
    : "The num 6 out range of list (9 20 3 49)"
    上面函数实现了从列表中取出第 n 个元素的功能，并在超出列表长度是输出提示。
    通过使用 elisp 提供的函数，我们事实上是可以把列表当数组来用。依惯例，我们用 car 来访问列表的第一个元素，cdr 来访问第二个元素，再往后就没有这样的函数了，可以用 nth 函数来访问：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (nth 3 '(0 1 2 3 4 5)))
    #+END_SRC

    #+RESULTS:
    : 3
    获得列表一个区间的函数有 nthcdr、last 和 butlast。nthcdr 和 last 比较类似，它们都是返回列表后端的列表。nthcdr 函数返回第 n 个元素后的列表。
    last 函数返回倒数 n 个长度的列表。
    butlast 和前两个函数不同，返回除了倒数 n 个元素的列表：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (nthcdr 2 '(0 1 2 3 4 5)))
      (print (last '(0 1 2 3 4 5) 2))
      (prin1 (butlast '(0 1 2 3 4 5) 2))
    #+END_SRC

    #+RESULTS:
    : (2 3 4 5)
    : (4 5)
    : (0 1 2 3)
    
    编写一个得到某个区间的列表函数：
    #+BEGIN_SRC emacs-lisp :results output
      (defun my-subseq (start end seq)
        (butlast (nthcdr start seq)
                 (- (length seq) end)))

      (setq test-list '(0 1 2 3 4 5))
      (prin1 (my-subseq 2 5 test-list))
      (print (my-subseq 1 4 test-list))
    #+END_SRC

    #+RESULTS:
    : (2 3 4)
    : (1 2 3)
    使用前面这个函数访问列表是没有问题了。但是你也可以想象，链表这种数据结构是不适合随机访问的，代价比较高，如果你的代码中频繁使用这样的函数或者对一个很长列表使用这样的函数，就应该考虑是不是用数组来实现。
    到目前为止，我们用到的函数都不会修改一个已有的变量。这是函数式编程的一个特点。只用这些函数编写的代码是很容易调试的，因为你不用去考虑一个变量在执行一个代码后就改变了，不用考虑变量的引用情况等等。
    首先学习怎样修改一个 cons cell 的内容。setcar 和 setcdr 可以修改一个 cons cell 的 CAR 部分和 CDR 部分。
    #+BEGIN_SRC emacs-lisp :results output
      (setq foo '(a b c))
      (setcar foo 'x)
      (prin1 foo)
      (setcdr foo '(y z))
      (print foo)
    #+END_SRC

    #+RESULTS:
    : (x b c)
    : (x y z)
    思考题
    #+BEGIN_SRC emacs-lisp :results output
      (setq foo '(a b c))
      (prin1 (setcdr foo foo))
    #+END_SRC

    #+RESULTS:
    : (a . #0)
    如何像数组那样修改列表。使用 setcar 和 nthcdr 的组合就可以实现：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (setq foo '(1 2 3)))
      (print (setcar foo 'a))
      (prin1 (setcar (cdr foo) 'b))
      (print (setcar (nthcdr 2 foo) 'c))
      (prin1 foo)
    #+END_SRC

    #+RESULTS:
    : (1 2 3)
    : a
    : b
    : c
    : (a b c)
    用列表当堆栈用
    前面提到过可以用 push 向列表头端增加元素，在结合 pop 函数，列表就可以做一个堆栈了。
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (setq foo nil))
      (print (push 'a foo))
      (prin1 (push 'b foo))
      (print (pop foo))
      (prin1 foo)
    #+END_SRC

    #+RESULTS:
    : nil
    : (a)
    : (b a)
    : b
    : (a)
    重排列表
    如果一直用 push 往列表里添加元素有一个问题是这样得到的列表和加入的顺序是相反的。通常我们需要得到一个反向的列表。reverse 函数可以做到这一点：
    #+BEGIN_SRC emacs-lisp :results output
      (prin1 (setq foo '(a b c)))
      (print (reverse foo))
    #+END_SRC

    #+RESULTS:
    : (a b c)
    : (c b a)

*** 数组和序列
*** 符号
** 求值规则
** 变量
** 函数和命令
** 正则表达式
** 操作对象
*** 缓冲区
*** 窗口
*** 文件
*** 文本
