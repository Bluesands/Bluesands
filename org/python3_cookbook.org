#+TITLE: Python3 CookBook Learning

*** 数据结构和算法
    Python 提供了大量的内置数据结构，包括列表、集合和字典。这里将讨论使用这些数据结构遇到的查询、排序和过滤等问题，并在集合模块 collections 当中操作菏泽写数据结构的方法。
**** 解压序列赋值给多个变量
     如何将一个包含 N 个元素的元组或序列解压赋值给 N 个变量？
     #+BEGIN_SRC python :exports both :results output
       p = (4, 5)
       x, y = p
       print(x, y)

       data = ['ACEM', 50, 91.1, (2012, 12, 21)]
       name, shares, price, date = data
       print(name, shares, price, date)

       name, shares, price, (year, mon, day) = data
       print(name, shares, price, year, mon, day)
     #+END_SRC

     #+RESULTS:
     : 4 5
     : ACEM 50 91.1 (2012, 12, 21)
     : ACEM 50 91.1 2012 12 21
    这种解压赋值可以用在任何可迭代对象上面，而不仅仅是列表或元组。包括字符串，文件对象，迭代器和生成器。
    #+BEGIN_SRC python :exports both :results output
      a, b, c, d, e = 'Hello'
      print(a, b, c, d, e)
      a, b, c, d = range(4)
      print(a, b, c, d)
    #+END_SRC

    #+RESULTS:
    : H e l l o
    : 0 1 2 3
    如果只需要部分值，可用任意不被用到的变量名去占位。

**** 解压可迭代对象赋值给多个变量
     如果一个可迭代对象的元素个数超过变量个数，会抛出一个 ValueError。则如何从这个可迭代对象中解压出 N 个元素呢？
     python 的星号表达式可以解决这个问题。
     #+BEGIN_SRC python :exports both :results output
       a, b, *c = [1, 2, 3, 4, 5]
       print(a, b, c)

       a, b, *c = range(10)
       print(a, b, c)

       a, *b, c = range(10)
       print(a, b, c)

       ,*a, b, c = range(10)
       print(a, b, c, end='')
     #+END_SRC

     #+RESULTS:
     : 1 2 [3, 4, 5]
     : 0 1 [2, 3, 4, 5, 6, 7, 8, 9]
     : 0 [1, 2, 3, 4, 5, 6, 7, 8] 9
     : [0, 1, 2, 3, 4, 5, 6, 7] 8 9
     注意：星号对应的变量永远是列表类型。
     扩展的迭代解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。通常这些可迭代对象的元素结构有确定的规则，特别是，星号表达式在迭代元素为可变长元组的序列时是很有用的。
     #+BEGIN_SRC python :exports both :results output
       records = [('foo', 1, 2), ('bar', 'hello'), ('foo', 3, 4)]


       def do_foo(x, y):
           print('foo', x, y)


       def do_bar(s):
           print('bar', s)


       for tag, *args in records:
           if tag == 'foo':
               do_foo(*args)
           elif tag == 'bar':
               do_bar(*args)
     #+END_SRC

     #+RESULTS:
     : foo 1 2
     : bar hello
     : foo 3 4
     
     星号解压语法在字符串操作的时候也会很有用，比如分割字符串：
     #+BEGIN_SRC python :exports both :results output
       line = 'nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false'
       uname, *fields, homedir, sh = line.split(':')
       print(uname, fields, homedir, sh)
     #+END_SRC

     #+RESULTS:
     : nobody ['*', '-2', '-2', 'Unprivileged User'] /var/empty /usr/bin/false

**** 保留组后 N 个元素
     在迭代操作或者其他操作时，怎样只保留最后有限几个元素的历史记录？
     保留有限历史记录正是 collections.deque 大显身手的时候。
     #+BEGIN_SRC python :exports both :results output
       from collections import deque


       file_lines = '''Python is powerful... and fast;
       plays well with others;
       runs everywhere;
       is friendly & easy to learn;
       is Open.
       These are some of the reasons people who use Python would rather not use anything else.

       Python can be easy to pick up whether you're a first time programmer
       or you're experienced with other languages.
       The following pages are a useful first step to get on your way
       writing programs with Python!

       The community hosts conferences and meetups, collaborates on code,
       and much more. Python's documentation will help you along the way,
       and the mailing lists will keep you in touch.

       Conferences and Workshops
       Python Documentation
       Mailing Lists and IRC channels'''


       def search(lines, pattern, history=5):
           previous_lines = deque(maxlen=history)
           for line in lines:
               if pattern in line:
                   yield line, previous_lines
               previous_lines.append(line)


       for line, prevlines in search(file_lines.split('\n'), 'Python', 5):
           for pline in prevlines:
               print(pline)
           print(line)
           print('-' * 15)
     #+END_SRC

     #+RESULTS:
     #+begin_example
     Python is powerful... and fast;
     ---------------
     Python is powerful... and fast;
     plays well with others;
     runs everywhere;
     is friendly & easy to learn;
     is Open.
     These are some of the reasons people who use Python would rather not use anything else.
     ---------------
     runs everywhere;
     is friendly & easy to learn;
     is Open.
     These are some of the reasons people who use Python would rather not use anything else.

     Python can be easy to pick up whether you're a first time programmer
     ---------------
     These are some of the reasons people who use Python would rather not use anything else.

     Python can be easy to pick up whether you're a first time programmer
     or you're experienced with other languages.
     The following pages are a useful first step to get on your way
     writing programs with Python!
     ---------------
     or you're experienced with other languages.
     The following pages are a useful first step to get on your way
     writing programs with Python!

     The community hosts conferences and meetups, collaborates on code,
     and much more. Python's documentation will help you along the way,
     ---------------
     The community hosts conferences and meetups, collaborates on code,
     and much more. Python's documentation will help you along the way,
     and the mailing lists will keep you in touch.

     Conferences and Workshops
     Python Documentation
     ---------------
     #+end_example

     其中 collections.deque 是一个双端队列.
     我们在写查询元素的代码时，通常会使用包含 yield 表达式的生成器函数，也就是我们上面代码示例。这样可以将搜索过程和使用搜索代码解耦。
     使用 deque(maxlen=N)构造函数会新建一个固定大小的队列，当新的元素加入并且这个队列已满的时候，最老的元素会自动被移除。
     #+BEGIN_SRC python :exports both :results output
       from collections import deque
       q = deque(maxlen=3)
       q.append(1)
       q.append(2)
       q.append(3)
       print(q)
       q.append(4)
       print(q)
       q.append(5)
       print(q, end='')
     #+END_SRC

     #+RESULTS:
     : deque([1, 2, 3], maxlen=3)
     : deque([2, 3, 4], maxlen=3)
     : deque([3, 4, 5], maxlen=3)
     使用 deque 队列方案会更优雅且运行更快。一般 deque 类可以被用在任何你只需要一个简单队列数据结构的场合。如果你不设置最大队列大小，那么就会得到一个无线大小队列，你可以在队列的两端执行添加和弹出元素的操作，其具体包含那么方法如下：
     #+BEGIN_SRC python :exports both :results output
       from collections import deque

       q = deque(maxlen=20)
       # 尾部添加数据
       q.append(1)
       q.append(2)
       print(q)
       # 头部添加数据
       q.appendleft(3)
       print(q)
       # 尾部扩展可迭代对象
       q.extend([4, 5])
       print(q)
       q.extend(range(3))
       print(q)
       # 头部扩展可迭代对象
       q.extendleft([6, 7])
       print(q)
       # 尾部移除
       q.pop()
       print(q)
       # 头部移除
       q.popleft()
       print(q)
       # 统计元素出现的个数
       print(q.count(1))
       # index 检索
       print(q.index(2))
       # 指定位置插入
       q.insert(13, 56)
       print(q, end='')
       # clear 清空队列
       # copy 复制队列
       # remove 移除队列中指定值
       # reverse 翻转队列
       # rotate 旋转队列
     #+END_SRC

     #+RESULTS:
     #+begin_example
     deque([1, 2], maxlen=20)
     deque([3, 1, 2], maxlen=20)
     deque([3, 1, 2, 4, 5], maxlen=20)
     deque([3, 1, 2, 4, 5, 0, 1, 2], maxlen=20)
     deque([7, 6, 3, 1, 2, 4, 5, 0, 1, 2], maxlen=20)
     deque([7, 6, 3, 1, 2, 4, 5, 0, 1], maxlen=20)
     deque([6, 3, 1, 2, 4, 5, 0, 1], maxlen=20)
     2
     3
     deque([6, 3, 1, 2, 4, 5, 0, 1, 56], maxlen=20)
     #+end_example

**** 查找最大或最小的 N 个元素
     如何从一个集合中获得最大或最小 N 个元素列表？
     heapq 模块有两个函数：nlargest()和 nsmallest()可以完美解决这两个问题。
     #+BEGIN_SRC python :exports both :results output
       import heapq

       nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
       print(heapq.nlargest(3, nums))
       print(heapq.nsmallest(3, nums))
     #+END_SRC

     #+RESULTS:
     : [42, 37, 23]
     : [-4, 1, 2]
     两个函数都能接受一个关键字参数，用于复杂的数据结构中：
     #+BEGIN_SRC python :exports both :results output
       import heapq
       from pprint import pprint

       portfolio = [{
           'name': 'IBM',
           'shares': 100,
           'price': 91.1
       }, {
           'name': 'AAPL',
           'shares': 50,
           'price': 543.22
       }, {
           'name': 'FB',
           'shares': 200,
           'price': 21.09
       }, {
           'name': 'HPQ',
           'shares': 35,
           'price': 31.75
       }, {
           'name': 'YHOO',
           'shares': 45,
           'price': 16.35
       }, {
           'name': 'ACME',
           'shares': 75,
           'price': 115.65
       }]

       cheap = heapq.nsmallest(3, portfolio, key=lambda x: x['price'])
       expensive = heapq.nlargest(3, portfolio, key=lambda x: x['price'])
       pprint(cheap)
       pprint(expensive)
     #+END_SRC

     #+RESULTS:
     : [{'name': 'YHOO', 'price': 16.35, 'shares': 45},
     :  {'name': 'FB', 'price': 21.09, 'shares': 200},
     :  {'name': 'HPQ', 'price': 31.75, 'shares': 35}]
     : [{'name': 'AAPL', 'price': 543.22, 'shares': 50},
     :  {'name': 'ACME', 'price': 115.65, 'shares': 75},
     :  {'name': 'IBM', 'price': 91.1, 'shares': 100}]
     key 的排序可以参考 sorted 函数的 key，都是可以采用匿名函数进行复杂排序的。

     如果你想在一个集合中查找最小或最大 N 个元素，并且 N 小于集合元素数量，那么这些函数提供了很好的性能。因为在底层实现里面，首先会先将集合数据进行堆排序后放入一个列表中：
     #+BEGIN_SRC python :exports both :results output
       import heapq

       nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2]
       heapq.heapify(nums)
       print(nums)
       print(heapq.heappop(nums))
       print(heapq.heappop(nums))
       uprint(heapq.heappop(nums))
     #+END_SRC

     #+RESULTS:
     : [-4, 2, 1, 23, 7, 2, 18, 23, 42, 37, 8]
     : -4
     : 1
     : 2
     堆数据结构最重要的特征是 heap[0]永远是最小的元素。并且剩余的元素都可以很容易通过调用 heapq.heappop()方法得到，该方法会先将地一个元素弹出，然后用下一个最小元素来取代被弹出的元素（这种操作时间复杂度仅仅是 O(logN)，N 是堆大小）。
     堆数据结构的实现是一个很有趣并且值得深入学习的东西，基本上只要是数据结构和算法书籍里都会提到。heapq 模块官方提供了详细的堆数据结构底层实现细节，可以参考研究一下。对于提高 python 是很有帮助的。
    
**** 实现一个优先级队列
     怎样实现一个按优先级排序的队列？并且在这个队列上每次 pop 操作总是返回优先级最高的那个元素？
     一下是利用 heapq 模块实现了一个简单的优先级队列：
     #+BEGIN_SRC python :exports both :results output
       import heapq


       class PriorityQueue(object):
           def __init__(self):
               self._queue = []
               self._index = 0

           def push(self, item, priority):
               heapq.heappush(self._queue, (-priority, self._index, item))
               self._index += 1

           def pop(self):
               return heapq.heappop(self._queue)[-1]


       class Item(object):
           def __init__(self, name):
               self.name = name

           def __repr__(self):
               return 'Item({!r})'.format(self.name)


       q = PriorityQueue()
       q.push(Item('foo'), 1)
       q.push(Item('bar'), 5)
       q.push(Item('spam'), 4)
       q.push(Item('grok'), 1)
       for _ in range(4):
           print(q.pop())
     #+END_SRC

     #+RESULTS:
     : Item('bar')
     : Item('spam')
     : Item('foo')
     : Item('grok')
     第一个 pop()操作返回优先级最高的元素。另外注意到如果两个有着相同优先级的元素(foo 和 grok），pop 操作按照它们传入到队列的顺序返回。
     这一节主要关注 heapq 模块。
*** 字符串和文本 
    
*** 数字日期和时间

*** 迭代器与生成器

*** 文本与 IO
*** 数据编码和处理

*** 函数

*** 类与对象

*** 元编程

*** 模块与包

*** 网络与 web 编程

*** 并发编程

*** 脚本编程与系统管理

*** 测试、调试和异常

*** C 语言扩展
